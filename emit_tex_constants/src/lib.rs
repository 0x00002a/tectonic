// Copyright 2017 the Tectonic Project
// Licensed under the MIT License.

/*!
This crate is a build-time helper for Tectonic that emits various pre-filled
C constants.
*/

extern crate regex;

use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufReader, Result, Write};
use std::path::Path;


pub fn emit_stringpool(listfile: &Path, outstem: &Path) -> Result<()> {
    let listing = BufReader::new(File::open(listfile)?);

    let c_escapes = regex::Regex::new(r#"([\\"])"#).unwrap();
    // Note: we intentionally mask out "Z"
    let bad_for_identifier = regex::Regex::new(r#"([^_a-zA-Y0-9])"#).unwrap();

    let mut source_path = outstem.to_path_buf();
    let mut header_path = source_path.clone();
    source_path.set_extension("c");
    header_path.set_extension("h");

    let mut source = File::create(source_path)?;
    let mut header = File::create(header_path)?;

    writeln!(source, "/* Automatically generated by emit_tex_constants. */")?;
    writeln!(header, "/* Automatically generated by emit_tex_constants. */")?;

    let mut i = 0;
    let mut counts = HashMap::new();

    for line in listing.lines() {
        let line = line?;

        // Converting the string to a C literal is pretty easy. Fortunately
        // only a few characters that need escaping ever appear. If things get
        // tricky we could always deploy \000 escapes.

        let str_lit = c_escapes.replace_all(&line, r"\$1");

        // Converting it to an identifier for the header file is harder. We
        // need to strip characters that don't work for C identifiers. We need
        // to disambiguate things that become the same after this stripping.
        // And it's nice to truncate relatively long strings. We ensure that
        // the disambiguation can't blow up on us by treating "Z" as a
        // non-letter in bad_for_identifier. "Z" does not occur in the XeTeX
        // string pool.

        let mut def_id = bad_for_identifier.replace_all(&line, "_").into_owned();
        def_id.truncate(28);

        let count = counts.entry(def_id.clone()).or_insert(0);
        let suffix = if *count == 0 {
            "".to_owned()
        } else {
            format!("_Z{0}", *count)
        };

        writeln!(source, r#""{0}","#, str_lit)?;
        writeln!(header, r#"#define S__{0}{1} {2} /* "{3}" */"#, def_id, suffix, i, str_lit)?;
        *count += 1;
        i += 1;
    }

    // TeX format files include a checksum of the string pool file
    // ("TEX.POOL") used to generate the string constants. For now, we
    // hard-code the number found in TeXLive XeTeX format files. If we, say,
    // rearrange things in the string pool, I think things might start subtly
    // breaking. So at some point we should actually take this checksum
    // seriously, but we can't do that until we start emitting our own format
    // files.

    writeln!(header, r#"#define STRING_POOL_CHECKSUM 457477274"#)?;

    Ok(())
}
