// Copyright 2017 the Tectonic Project
// Licensed under the MIT License.

/*!
This crate is a build-time helper for Tectonic that emits various pre-filled
C constants.
*/

extern crate regex;
extern crate sha2;

use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufReader, Result, Write};
use std::path::Path;

use sha2::Digest;


pub fn emit_stringpool(listfile: &Path, outstem: &Path) -> Result<()> {
    let listing = BufReader::new(File::open(listfile)?);

    let c_escapes = regex::Regex::new(r#"([\\"])"#).unwrap();
    // Note: we intentionally mask out "Z"
    let bad_for_identifier = regex::Regex::new(r#"([^_a-zA-Y0-9])"#).unwrap();

    let mut source_path = outstem.to_path_buf();
    let mut header_path = source_path.clone();
    source_path.set_extension("c");
    header_path.set_extension("h");

    let mut source = File::create(source_path)?;
    let mut header = File::create(header_path)?;

    writeln!(source, "/* Automatically generated by emit_tex_constants. */")?;
    writeln!(header, "/* Automatically generated by emit_tex_constants. */")?;

    let mut i = 0;
    let mut counts = HashMap::new();
    let mut digest = sha2::Sha256::default();

    for line in listing.lines() {
        let line = line?;

        // Converting the string to a C literal is pretty easy. Fortunately
        // only a few characters that need escaping ever appear. If things get
        // tricky we could always deploy \000 escapes.

        let str_lit = c_escapes.replace_all(&line, r"\$1");

        // Converting it to an identifier for the header file is harder. We
        // need to strip characters that don't work for C identifiers. We need
        // to disambiguate things that become the same after this stripping.
        // And it's nice to truncate relatively long strings. We ensure that
        // the disambiguation can't blow up on us by treating "Z" as a
        // non-letter in bad_for_identifier. "Z" does not occur in the XeTeX
        // string pool.

        let mut def_id = bad_for_identifier.replace_all(&line, "_").into_owned();
        def_id.truncate(28);

        let count = counts.entry(def_id.clone()).or_insert(0);
        let suffix = if *count == 0 {
            "".to_owned()
        } else {
            format!("_Z{0}", *count)
        };

        digest.input(&line.as_bytes());
        digest.input(&[0u8]);
        writeln!(source, r#""{0}","#, str_lit)?;
        writeln!(header, r#"#define S__{0}{1} {2} /* "{3}" */"#, def_id, suffix, i, str_lit)?;
        *count += 1;
        i += 1;
    }

    // TeX format files include a checksum of the string pool file
    // ("TEX.POOL") used to generate the string constants. We are no longer
    // compatible with TeX(Live) format files so we are free to compute the
    // digest as we please. We just take the first 31 bits (almost). I'm on a
    // plane and not able to search for the sensible way to do this, so we do
    // it in a silly way.

    let buf = digest.result();
    let hash: u32 = ((buf[0] as u32) & 0x7F) << 24 | (buf[1] as u32) << 16 | (buf[2] as u32) << 8 | (buf[3] as u32);
    writeln!(header, r#"#define STRING_POOL_CHECKSUM {}"#, hash)?;

    Ok(())
}
